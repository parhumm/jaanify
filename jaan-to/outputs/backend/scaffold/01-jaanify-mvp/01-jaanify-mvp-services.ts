// Jaanify MVP — Service Layer
// Generated by jaan.to backend-scaffold | 2026-02-09
// Plain exported functions — module caching acts as singleton (no DI needed)
// Testable via vi.mock(); callable from CRON/queue consumers outside HTTP context

import { prisma } from "../lib/prisma.js";
import type {
  TaskCreate,
  TaskUpdate,
  TaskListQuery,
  TaskParseRequest,
  TaskParseResponse,
  FeedbackCreate,
  GuestSessionCreate,
  DailyPlanSlotUpdate,
  UserUpdate,
} from "./schemas.js";

// ── Auth Service ───────────────────────────────────

export async function authenticateWithGoogle(code: string, redirectUri: string) {
  // TODO: Exchange code with Google OAuth2 API
  // 1. Call https://oauth2.googleapis.com/token with code + redirect_uri
  // 2. Decode ID token to get email, name, picture
  // 3. Upsert user record (create if new, update if existing)
  // 4. Generate JWT access token (1h) + refresh token (7d)
  // 5. Return AuthTokens
  throw new Error("Not implemented: Google OAuth2 exchange");
}

export async function refreshAccessToken(refreshToken: string) {
  // TODO: Validate refresh token, generate new token pair
  // 1. Verify refresh token signature + expiry
  // 2. Look up user by token subject
  // 3. Generate new access token + rotate refresh token
  // 4. Return AuthTokens
  throw new Error("Not implemented: Token refresh");
}

export async function registerFromGuest(
  anonymousId: string,
  provider: string,
  code: string
) {
  return prisma.$transaction(async (tx) => {
    // 1. Find guest session
    const guest = await tx.guestSession.findUnique({
      where: { anonymousId },
    });
    if (!guest) throw new Error("Guest session not found");

    // 2. Create user from OAuth/email verification
    // TODO: Exchange code with provider to get user info
    const user = await tx.user.create({
      data: {
        email: null, // TODO: from provider response
        name: null, // TODO: from provider response
        authProvider: provider,
        preferencesJson: guest.dataJson ?? {},
      },
    });

    // 3. Migrate guest tasks to new user
    // TODO: If guest session stored task IDs, reassign them

    // 4. Delete guest session
    await tx.guestSession.delete({ where: { anonymousId } });

    // 5. Generate tokens
    // TODO: Generate JWT + refresh token for new user
    return {
      access_token: "TODO",
      token_type: "Bearer" as const,
      expires_in: 3600,
    };
  });
}

export async function invalidateRefreshToken(userId: string) {
  // TODO: Invalidate refresh token for user
  // Could use Redis blacklist or DB-stored token revocation
}

// ── User Service ───────────────────────────────────

export async function getUserById(userId: string) {
  return prisma.user.findUniqueOrThrow({
    where: { id: userId, deletedAt: null },
  });
}

export async function updateUser(userId: string, data: UserUpdate) {
  return prisma.user.update({
    where: { id: userId, deletedAt: null },
    data: {
      ...(data.name !== undefined && { name: data.name }),
      ...(data.avatar_url !== undefined && { avatarUrl: data.avatar_url }),
      ...(data.preferences_json !== undefined && {
        preferencesJson: data.preferences_json,
      }),
    },
  });
}

export async function softDeleteUser(userId: string) {
  return prisma.user.update({
    where: { id: userId, deletedAt: null },
    data: { deletedAt: new Date() },
  });
}

// ── Task Service ───────────────────────────────────

export async function listTasks(userId: string, query: TaskListQuery) {
  const { cursor, limit, status, category } = query;

  const where = {
    userId,
    deletedAt: null,
    ...(status && { status }),
    ...(category && { category }),
    ...(cursor && { id: { lt: cursor } }),
  };

  const tasks = await prisma.task.findMany({
    where,
    orderBy: { createdAt: "desc" },
    take: limit + 1, // Fetch one extra to check has_more
  });

  const hasMore = tasks.length > limit;
  const data = hasMore ? tasks.slice(0, limit) : tasks;

  return {
    data,
    pagination: {
      cursor: hasMore ? data[data.length - 1]?.id ?? null : null,
      has_more: hasMore,
      limit,
    },
  };
}

export async function createTask(userId: string, input: TaskCreate) {
  let enrichedData = {};

  // If raw_input provided, trigger AI parsing
  if (input.raw_input) {
    const parsed = await parseTaskInput({ input: input.raw_input });
    enrichedData = {
      deadline: parsed.deadline ? new Date(parsed.deadline) : null,
      category: parsed.category,
      energyLevel: parsed.energy_level,
      estimatedMinutes: parsed.estimated_minutes,
      reasoningJson: parsed.reasoning ?? null,
      priorityScore: parsed.confidence ?? 0.5,
    };
  }

  return prisma.task.create({
    data: {
      userId,
      title: input.title,
      rawInput: input.raw_input ?? null,
      description: input.description ?? null,
      deadline: input.deadline ? new Date(input.deadline) : null,
      category: input.category ?? null,
      energyLevel: input.energy_level ?? null,
      estimatedMinutes: input.estimated_minutes ?? null,
      ...enrichedData,
    },
  });
}

export async function getTask(userId: string, taskId: string) {
  return prisma.task.findFirstOrThrow({
    where: { id: taskId, userId, deletedAt: null },
  });
}

export async function updateTask(userId: string, taskId: string, data: TaskUpdate) {
  const updateData: Record<string, unknown> = {};

  if (data.title !== undefined) updateData.title = data.title;
  if (data.description !== undefined) updateData.description = data.description;
  if (data.deadline !== undefined)
    updateData.deadline = data.deadline ? new Date(data.deadline) : null;
  if (data.category !== undefined) updateData.category = data.category;
  if (data.status !== undefined) {
    updateData.status = data.status;
    if (data.status === "completed") updateData.completedAt = new Date();
  }
  if (data.energy_level !== undefined) updateData.energyLevel = data.energy_level;
  if (data.estimated_minutes !== undefined)
    updateData.estimatedMinutes = data.estimated_minutes;
  if (data.priority_override !== undefined)
    updateData.priorityOverride = data.priority_override;

  return prisma.task.update({
    where: { id: taskId, userId, deletedAt: null },
    data: updateData,
  });
}

export async function softDeleteTask(userId: string, taskId: string) {
  return prisma.task.update({
    where: { id: taskId, userId, deletedAt: null },
    data: { deletedAt: new Date() },
  });
}

export async function parseTaskInput(
  input: TaskParseRequest
): Promise<TaskParseResponse> {
  // TODO: Integrate with OpenAI SDK for NLP parsing
  // 1. Send input.input to OpenAI with structured output schema
  // 2. Extract: title, deadline, category, energy_level, estimated_minutes
  // 3. Return with confidence score + reasoning
  return {
    title: input.input.slice(0, 100),
    deadline: null,
    category: null,
    energy_level: null,
    estimated_minutes: null,
    confidence: 0.5,
    reasoning: { note: "AI parsing not yet implemented" },
  };
}

// ── Daily Plan Service ─────────────────────────────

export async function listDailyPlans(userId: string, query: { cursor?: string; limit: number }) {
  const { cursor, limit } = query;

  const plans = await prisma.dailyPlan.findMany({
    where: {
      userId,
      ...(cursor && { id: { lt: cursor } }),
    },
    include: { slots: { orderBy: { position: "asc" } } },
    orderBy: { date: "desc" },
    take: limit + 1,
  });

  const hasMore = plans.length > limit;
  const data = hasMore ? plans.slice(0, limit) : plans;

  return {
    data,
    pagination: {
      cursor: hasMore ? data[data.length - 1]?.id ?? null : null,
      has_more: hasMore,
      limit,
    },
  };
}

export async function generateDailyPlan(userId: string) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const dateStr = today.toISOString().split("T")[0]!;

  // Check for existing plan today
  const existing = await prisma.dailyPlan.findUnique({
    where: { userId_date: { userId, date: new Date(dateStr) } },
  });
  if (existing) {
    throw Object.assign(new Error("Plan already exists for today"), {
      statusCode: 409,
    });
  }

  return prisma.$transaction(async (tx) => {
    // 1. Create plan in "generating" status
    const plan = await tx.dailyPlan.create({
      data: {
        userId,
        date: new Date(dateStr),
        status: "generating",
        reasoningMethod: "ai",
      },
    });

    // 2. Get active tasks for user, ordered by priority
    const tasks = await tx.task.findMany({
      where: { userId, status: "active", deletedAt: null },
      orderBy: { priorityScore: "desc" },
      take: 10, // Limit to top 10 tasks for daily plan
    });

    // 3. Create slots with AI reasoning
    // TODO: Call OpenAI to optimize task ordering based on:
    //   - deadline proximity, energy match, dependencies, user preferences
    const slots = await Promise.all(
      tasks.map((task, index) =>
        tx.dailyPlanSlot.create({
          data: {
            planId: plan.id,
            taskId: task.id,
            position: index + 1,
            status: "pending",
            reasoningJson: {
              tier1: `#${index + 1}: Priority score ${task.priorityScore}`,
              factors: {
                deadline_proximity: 0.3,
                energy_match: 0.25,
                dependency_chain: 0.25,
                user_preference: 0.2,
              },
              confidence: 0.7,
            },
          },
        })
      )
    );

    // 4. Update plan to active
    const activePlan = await tx.dailyPlan.update({
      where: { id: plan.id },
      data: {
        status: "active",
        generatedAt: new Date(),
      },
      include: { slots: { orderBy: { position: "asc" } } },
    });

    return activePlan;
  });
}

export async function getDailyPlan(userId: string, planId: string) {
  return prisma.dailyPlan.findFirstOrThrow({
    where: { id: planId, userId },
    include: { slots: { orderBy: { position: "asc" } } },
  });
}

export async function updatePlanSlot(
  userId: string,
  planId: string,
  slotId: string,
  data: DailyPlanSlotUpdate
) {
  // Verify plan ownership
  await prisma.dailyPlan.findFirstOrThrow({
    where: { id: planId, userId },
  });

  return prisma.dailyPlanSlot.update({
    where: { id: slotId, planId },
    data: {
      ...(data.position !== undefined && { position: data.position }),
      ...(data.status !== undefined && { status: data.status }),
    },
  });
}

// ── Feedback Service ───────────────────────────────

export async function createFeedback(userId: string, input: FeedbackCreate) {
  return prisma.userFeedback.create({
    data: {
      userId,
      taskId: input.task_id ?? null,
      planId: input.plan_id ?? null,
      feedbackType: input.feedback_type,
      reason: input.reason ?? null,
    },
  });
}

// ── Guest Session Service ──────────────────────────

export async function createGuestSession(input: GuestSessionCreate) {
  const anonymousId = `anon_${crypto.randomUUID().replace(/-/g, "").slice(0, 16)}`;
  const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

  return prisma.guestSession.create({
    data: {
      anonymousId,
      dataJson: input.data_json ?? {},
      expiresAt,
    },
  });
}

export async function getGuestSession(anonymousId: string) {
  const session = await prisma.guestSession.findUniqueOrThrow({
    where: { anonymousId },
  });

  if (session.expiresAt < new Date()) {
    await prisma.guestSession.delete({ where: { anonymousId } });
    throw Object.assign(new Error("Guest session expired"), { statusCode: 404 });
  }

  return session;
}

// ── Audit Log Service ──────────────────────────────

export async function createAuditLog(
  userId: string | null,
  action: string,
  entityType: string,
  entityId: string | null,
  metadata: Record<string, unknown> = {}
) {
  return prisma.auditLog.create({
    data: {
      userId,
      action,
      entityType,
      entityId,
      metadata,
    },
  });
}

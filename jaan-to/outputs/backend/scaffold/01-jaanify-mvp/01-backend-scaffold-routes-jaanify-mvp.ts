// Jaanify MVP — Route Handlers (All 21 Endpoints)
// Generated by jaan.to backend-scaffold | 2026-02-09
// Fastify v5 + fastify-type-provider-zod v6.1
// Each route file is auto-loaded by @fastify/autoload

import type { FastifyInstance } from "fastify";
import type { ZodTypeProvider } from "fastify-type-provider-zod";
import * as schemas from "./schemas.js";
import * as services from "./services.js";

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// AUTH ROUTES — /v1/auth/*
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function authRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // POST /auth/google — Authenticate via Google OAuth2
  f.post(
    "/auth/google",
    {
      schema: {
        body: schemas.googleAuthRequestSchema,
        response: { 200: schemas.authTokensSchema },
      },
    },
    async (request, reply) => {
      const tokens = await services.authenticateWithGoogle(
        request.body.code,
        request.body.redirect_uri
      );
      return reply.send(tokens);
    }
  );

  // POST /auth/refresh — Refresh access token
  f.post(
    "/auth/refresh",
    {
      schema: {
        response: { 200: schemas.authTokensSchema },
      },
    },
    async (request, reply) => {
      // TODO: Extract refresh token from httpOnly cookie
      const refreshToken = request.cookies?.refresh_token ?? "";
      const tokens = await services.refreshAccessToken(refreshToken);
      return reply.send(tokens);
    }
  );

  // POST /auth/register — Convert guest to registered account
  f.post(
    "/auth/register",
    {
      schema: {
        body: schemas.registerRequestSchema,
        response: { 201: schemas.authTokensSchema },
      },
    },
    async (request, reply) => {
      const { anonymous_id, provider, code } = request.body;
      const tokens = await services.registerFromGuest(anonymous_id, provider, code);
      return reply.status(201).send(tokens);
    }
  );

  // DELETE /auth/logout — Invalidate tokens
  f.delete("/auth/logout", async (request, reply) => {
    await services.invalidateRefreshToken(request.userId);
    return reply.status(204).send();
  });
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// USER ROUTES — /v1/users/*
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function userRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // GET /users/me — Get current user
  f.get(
    "/users/me",
    {
      schema: {
        response: { 200: schemas.userResponseSchema },
      },
    },
    async (request, reply) => {
      const user = await services.getUserById(request.userId);
      return reply.send(formatUserResponse(user));
    }
  );

  // PATCH /users/me — Update current user
  f.patch(
    "/users/me",
    {
      schema: {
        body: schemas.userUpdateSchema,
        response: { 200: schemas.userResponseSchema },
      },
    },
    async (request, reply) => {
      const user = await services.updateUser(request.userId, request.body);
      return reply.send(formatUserResponse(user));
    }
  );

  // DELETE /users/me — Soft-delete account
  f.delete("/users/me", async (request, reply) => {
    await services.softDeleteUser(request.userId);
    return reply.status(204).send();
  });
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// TASK ROUTES — /v1/tasks/*
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function taskRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // GET /tasks — List user's tasks (paginated)
  f.get(
    "/tasks",
    {
      schema: {
        querystring: schemas.taskListQuerySchema,
      },
    },
    async (request, reply) => {
      const result = await services.listTasks(request.userId, request.query);
      return reply.send({
        data: result.data.map(formatTaskResponse),
        pagination: result.pagination,
      });
    }
  );

  // POST /tasks — Create a new task
  f.post(
    "/tasks",
    {
      schema: {
        body: schemas.taskCreateSchema,
        response: { 201: schemas.taskResponseSchema },
      },
    },
    async (request, reply) => {
      const task = await services.createTask(request.userId, request.body);
      return reply
        .status(201)
        .header("Location", `/v1/tasks/${task.id}`)
        .send(formatTaskResponse(task));
    }
  );

  // POST /tasks/parse — AI parse (preview only)
  f.post(
    "/tasks/parse",
    {
      schema: {
        body: schemas.taskParseRequestSchema,
        response: { 200: schemas.taskParseResponseSchema },
      },
    },
    async (request, reply) => {
      const parsed = await services.parseTaskInput(request.body);
      return reply.send(parsed);
    }
  );

  // GET /tasks/:task_id — Get single task
  f.get(
    "/tasks/:task_id",
    {
      schema: {
        params: schemas.uuidParamSchema,
      },
    },
    async (request, reply) => {
      const task = await services.getTask(request.userId, request.params.task_id);
      return reply.send(formatTaskResponse(task));
    }
  );

  // PATCH /tasks/:task_id — Update task
  f.patch(
    "/tasks/:task_id",
    {
      schema: {
        params: schemas.uuidParamSchema,
        body: schemas.taskUpdateSchema,
      },
    },
    async (request, reply) => {
      const task = await services.updateTask(
        request.userId,
        request.params.task_id,
        request.body
      );
      return reply.send(formatTaskResponse(task));
    }
  );

  // DELETE /tasks/:task_id — Soft-delete task
  f.delete(
    "/tasks/:task_id",
    {
      schema: {
        params: schemas.uuidParamSchema,
      },
    },
    async (request, reply) => {
      await services.softDeleteTask(request.userId, request.params.task_id);
      return reply.status(204).send();
    }
  );
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// DAILY PLAN ROUTES — /v1/daily-plans/*
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function dailyPlanRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // GET /daily-plans — List plans (paginated)
  f.get(
    "/daily-plans",
    {
      schema: {
        querystring: schemas.cursorParamSchema,
      },
    },
    async (request, reply) => {
      const result = await services.listDailyPlans(request.userId, request.query);
      return reply.send({
        data: result.data.map(formatDailyPlanResponse),
        pagination: result.pagination,
      });
    }
  );

  // POST /daily-plans/generate — Generate today's AI plan
  f.post(
    "/daily-plans/generate",
    {
      schema: {
        response: { 201: schemas.dailyPlanResponseSchema },
      },
    },
    async (request, reply) => {
      const plan = await services.generateDailyPlan(request.userId);
      return reply.status(201).send(formatDailyPlanResponse(plan));
    }
  );

  // GET /daily-plans/:plan_id — Get plan with slots
  f.get(
    "/daily-plans/:plan_id",
    {
      schema: {
        params: schemas.planIdParamSchema,
      },
    },
    async (request, reply) => {
      const plan = await services.getDailyPlan(request.userId, request.params.plan_id);
      return reply.send(formatDailyPlanResponse(plan));
    }
  );

  // PATCH /daily-plans/:plan_id/slots/:slot_id — Update slot
  f.patch(
    "/daily-plans/:plan_id/slots/:slot_id",
    {
      schema: {
        params: schemas.slotIdParamSchema,
        body: schemas.dailyPlanSlotUpdateSchema,
      },
    },
    async (request, reply) => {
      const slot = await services.updatePlanSlot(
        request.userId,
        request.params.plan_id,
        request.params.slot_id,
        request.body
      );
      return reply.send(formatSlotResponse(slot));
    }
  );
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// FEEDBACK ROUTES — /v1/feedback
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function feedbackRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // POST /feedback — Submit AI feedback
  f.post(
    "/feedback",
    {
      schema: {
        body: schemas.feedbackCreateSchema,
        response: { 201: schemas.feedbackResponseSchema },
      },
    },
    async (request, reply) => {
      const feedback = await services.createFeedback(request.userId, request.body);
      return reply.status(201).send(formatFeedbackResponse(feedback));
    }
  );
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// GUEST SESSION ROUTES — /v1/guest-sessions/*
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

export async function guestSessionRoutes(fastify: FastifyInstance) {
  const f = fastify.withTypeProvider<ZodTypeProvider>();

  // POST /guest-sessions — Create anonymous session
  f.post(
    "/guest-sessions",
    {
      schema: {
        body: schemas.guestSessionCreateSchema,
        response: { 201: schemas.guestSessionResponseSchema },
      },
    },
    async (request, reply) => {
      const session = await services.createGuestSession(request.body);
      return reply.status(201).send(formatGuestSessionResponse(session));
    }
  );

  // GET /guest-sessions/:anonymous_id — Get session
  f.get(
    "/guest-sessions/:anonymous_id",
    {
      schema: {
        params: schemas.anonymousIdParamSchema,
      },
    },
    async (request, reply) => {
      const session = await services.getGuestSession(request.params.anonymous_id);
      return reply.send(formatGuestSessionResponse(session));
    }
  );
}

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// RESPONSE FORMATTERS (Prisma → API shape)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

function formatUserResponse(user: Record<string, unknown>) {
  return {
    id: user.id,
    email: user.email ?? null,
    name: user.name ?? null,
    avatar_url: user.avatarUrl ?? null,
    auth_provider: user.authProvider,
    preferences_json: user.preferencesJson ?? {},
    created_at: (user.createdAt as Date).toISOString(),
    updated_at: (user.updatedAt as Date).toISOString(),
  };
}

function formatTaskResponse(task: Record<string, unknown>) {
  return {
    id: task.id,
    user_id: task.userId,
    title: task.title,
    raw_input: task.rawInput ?? null,
    description: task.description ?? null,
    deadline: task.deadline ? (task.deadline as Date).toISOString() : null,
    category: task.category ?? null,
    priority_score: Number(task.priorityScore),
    priority_override: task.priorityOverride ?? null,
    status: task.status,
    reasoning_json: task.reasoningJson ?? null,
    energy_level: task.energyLevel ?? null,
    estimated_minutes: task.estimatedMinutes ?? null,
    completed_at: task.completedAt ? (task.completedAt as Date).toISOString() : null,
    created_at: (task.createdAt as Date).toISOString(),
    updated_at: (task.updatedAt as Date).toISOString(),
  };
}

function formatDailyPlanResponse(plan: Record<string, unknown>) {
  const slots = (plan.slots as Record<string, unknown>[]) ?? [];
  return {
    id: plan.id,
    user_id: plan.userId,
    date: (plan.date as Date).toISOString().split("T")[0],
    status: plan.status,
    reasoning_method: plan.reasoningMethod,
    generated_at: plan.generatedAt ? (plan.generatedAt as Date).toISOString() : null,
    slots: slots.map(formatSlotResponse),
    created_at: (plan.createdAt as Date).toISOString(),
    updated_at: (plan.updatedAt as Date).toISOString(),
  };
}

function formatSlotResponse(slot: Record<string, unknown>) {
  return {
    id: slot.id,
    plan_id: slot.planId,
    task_id: slot.taskId,
    position: slot.position,
    reasoning_json: slot.reasoningJson ?? null,
    status: slot.status,
  };
}

function formatFeedbackResponse(feedback: Record<string, unknown>) {
  return {
    id: feedback.id,
    user_id: feedback.userId,
    task_id: feedback.taskId ?? null,
    plan_id: feedback.planId ?? null,
    feedback_type: feedback.feedbackType,
    reason: feedback.reason ?? null,
    created_at: (feedback.createdAt as Date).toISOString(),
  };
}

function formatGuestSessionResponse(session: Record<string, unknown>) {
  return {
    id: session.id,
    anonymous_id: session.anonymousId,
    data_json: session.dataJson ?? {},
    expires_at: (session.expiresAt as Date).toISOString(),
    created_at: (session.createdAt as Date).toISOString(),
  };
}
